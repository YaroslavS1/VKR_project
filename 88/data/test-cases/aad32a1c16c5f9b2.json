{
  "uid" : "aad32a1c16c5f9b2",
  "name" : "test_count_summary_cost_ads",
  "fullName" : "vkr_project_tests.test_attach#test_count_summary_cost_ads",
  "historyId" : "510998b91d3f9014f7c6dfe23bddced0",
  "time" : {
    "start" : 1649585828371,
    "stop" : 1649585828372,
    "duration" : 1
  },
  "description" : "Calculation of the total cost of advertising",
  "descriptionHtml" : "<p>Calculation of the total cost of advertising</p>\n",
  "status" : "skipped",
  "statusMessage" : "XFAIL this test is expecting failure\n\nFileNotFoundError: [Errno 2] No such file or directory: '../case/cashe.csv'",
  "statusTrace" : "@pytest.mark.xfail(condition=lambda: True, reason='this test is expecting failure')\n    def test_count_summary_cost_ads():\n        \"\"\"Calculation of the total cost of advertising\"\"\"\n        '''\n        суть теста разложить сколько мы заплатили по дням\n        распечатать это\n        и ссумировать\n        '''\n        LOGGER.debug(f'{os. getcwd()}')\n        print(os. getcwd())\n>       f_data = pd.read_csv(\"../case/cashe.csv\", header=1, sep='\t', index_col=0, )\n\nvkr_project_tests/test_attach.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/util/_decorators.py:311: in wrapper\n    return func(*args, **kwargs)\n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/io/parsers/readers.py:680: in read_csv\n    return _read(filepath_or_buffer, kwds)\n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/io/parsers/readers.py:575: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/io/parsers/readers.py:933: in __init__\n    self._engine = self._make_engine(f, self.engine)\n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/io/parsers/readers.py:1217: in _make_engine\n    self.handles = get_handle(  # type: ignore[call-overload]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '../case/cashe.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n            .. versionchanged:: 1.0.0\n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n            .. versionchanged:: 1.1.0\n               Passing compression options as keys in dict is now\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        .. versionchanged:: 1.2.0\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        handle, memory_map, handles = _maybe_memory_map(\n            handle,\n            memory_map,\n            ioargs.encoding,\n            ioargs.mode,\n            errors,\n            ioargs.compression[\"method\"] not in _compression_to_extension,\n        )\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    assert isinstance(handle, str)\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # No overload variant of \"BZ2File\" matches argument types\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = bz2.BZ2File(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                handle = get_lzma_file()(handle, ioargs.mode)\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '../case/cashe.csv'\n\n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/io/common.py:789: FileNotFoundError",
  "flaky" : false,
  "newFailed" : false,
  "beforeStages" : [ ],
  "testStage" : {
    "description" : "Calculation of the total cost of advertising",
    "status" : "skipped",
    "statusMessage" : "XFAIL this test is expecting failure\n\nFileNotFoundError: [Errno 2] No such file or directory: '../case/cashe.csv'",
    "statusTrace" : "@pytest.mark.xfail(condition=lambda: True, reason='this test is expecting failure')\n    def test_count_summary_cost_ads():\n        \"\"\"Calculation of the total cost of advertising\"\"\"\n        '''\n        суть теста разложить сколько мы заплатили по дням\n        распечатать это\n        и ссумировать\n        '''\n        LOGGER.debug(f'{os. getcwd()}')\n        print(os. getcwd())\n>       f_data = pd.read_csv(\"../case/cashe.csv\", header=1, sep='\t', index_col=0, )\n\nvkr_project_tests/test_attach.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/util/_decorators.py:311: in wrapper\n    return func(*args, **kwargs)\n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/io/parsers/readers.py:680: in read_csv\n    return _read(filepath_or_buffer, kwds)\n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/io/parsers/readers.py:575: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/io/parsers/readers.py:933: in __init__\n    self._engine = self._make_engine(f, self.engine)\n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/io/parsers/readers.py:1217: in _make_engine\n    self.handles = get_handle(  # type: ignore[call-overload]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = '../case/cashe.csv', mode = 'r'\n\n    @doc(compression_options=_shared_docs[\"compression_options\"] % \"path_or_buf\")\n    def get_handle(\n        path_or_buf: FilePath | BaseBuffer,\n        mode: str,\n        *,\n        encoding: str | None = None,\n        compression: CompressionOptions = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions = None,\n    ) -> IOHandles[str] | IOHandles[bytes]:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        {compression_options}\n    \n            .. versionchanged:: 1.0.0\n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n            .. versionchanged:: 1.1.0\n               Passing compression options as keys in dict is now\n               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.\n    \n            .. versionchanged:: 1.4.0 Zstandard support.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        .. versionchanged:: 1.2.0\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # validate encoding and errors\n        codecs.lookup(encoding)\n        if isinstance(errors, str):\n            codecs.lookup_error(errors)\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[BaseBuffer]\n    \n        # memory mapping needs to be the first step\n        handle, memory_map, handles = _maybe_memory_map(\n            handle,\n            memory_map,\n            ioargs.encoding,\n            ioargs.mode,\n            errors,\n            ioargs.compression[\"method\"] not in _compression_to_extension,\n        )\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        # Only for write methods\n        if \"r\" not in mode and is_path:\n            check_parent_directory(str(handle))\n    \n        if compression:\n            if compression != \"zstd\":\n                # compression libraries do not like an explicit text-mode\n                ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n            elif compression == \"zstd\" and \"b\" not in ioargs.mode:\n                # python-zstandard defaults to text mode, but we always expect\n                # compression libraries to use binary mode.\n                ioargs.mode += \"b\"\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    assert isinstance(handle, str)\n                    # error: Incompatible types in assignment (expression has type\n                    # \"GzipFile\", variable has type \"Union[str, BaseBuffer]\")\n                    handle = gzip.GzipFile(  # type: ignore[assignment]\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # No overload variant of \"GzipFile\" matches argument types\n                        # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                        fileobj=handle,  # type: ignore[call-overload]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                # No overload variant of \"BZ2File\" matches argument types\n                # \"Union[str, BaseBuffer]\", \"str\", \"Dict[str, Any]\"\n                handle = bz2.BZ2File(  # type: ignore[call-overload]\n                    handle,\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                # error: Argument 1 to \"_BytesZipFile\" has incompatible type \"Union[str,\n                # BaseBuffer]\"; expected \"Union[Union[str, PathLike[str]],\n                # ReadBuffer[bytes], WriteBuffer[bytes]]\"\n                handle = _BytesZipFile(\n                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]\n                )\n                if handle.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                handle = get_lzma_file()(handle, ioargs.mode)\n    \n            # Zstd Compression\n            elif compression == \"zstd\":\n                zstd = import_optional_dependency(\"zstandard\")\n                if \"r\" in ioargs.mode:\n                    open_args = {\"dctx\": zstd.ZstdDecompressor(**compression_args)}\n                else:\n                    open_args = {\"cctx\": zstd.ZstdCompressor(**compression_args)}\n                handle = zstd.open(\n                    handle,\n                    mode=ioargs.mode,\n                    **open_args,\n                )\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: '../case/cashe.csv'\n\n/opt/hostedtoolcache/Python/3.10.4/x64/lib/python3.10/site-packages/pandas/io/common.py:789: FileNotFoundError",
    "steps" : [ ],
    "attachments" : [ {
      "uid" : "ede0fdc334e21a69",
      "name" : "stdout",
      "source" : "ede0fdc334e21a69.txt",
      "type" : "text/plain",
      "size" : 42
    } ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 1,
    "shouldDisplayMessage" : true,
    "hasContent" : true
  },
  "afterStages" : [ ],
  "labels" : [ {
    "name" : "tag",
    "value" : "@pytest.mark.xfail(condition=<function <lambda> at 0x7f1698de8310>, reason='this test is expecting failure')"
  }, {
    "name" : "parentSuite",
    "value" : "vkr_project_tests"
  }, {
    "name" : "suite",
    "value" : "test_attach"
  }, {
    "name" : "host",
    "value" : "fv-az47-201"
  }, {
    "name" : "thread",
    "value" : "2262-MainThread"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "package",
    "value" : "vkr_project_tests.test_attach"
  }, {
    "name" : "resultFormat",
    "value" : "allure2"
  } ],
  "parameters" : [ ],
  "links" : [ ],
  "hidden" : false,
  "retry" : false,
  "extra" : {
    "severity" : "normal",
    "retries" : [ ],
    "categories" : [ ],
    "history" : {
      "statistic" : {
        "failed" : 0,
        "broken" : 0,
        "skipped" : 3,
        "passed" : 0,
        "unknown" : 0,
        "total" : 3
      },
      "items" : [ {
        "uid" : "a3ad293c5fa92e3b",
        "reportUrl" : "https://YaroslavS1.github.io/VKR_project/87//#testresult/a3ad293c5fa92e3b",
        "status" : "skipped",
        "statusDetails" : "XFAIL this test is expecting failure\n\nFileNotFoundError: [Errno 2] No such file or directory: '../case/cashe.csv'",
        "time" : {
          "start" : 1649585048630,
          "stop" : 1649585048631,
          "duration" : 1
        }
      }, {
        "uid" : "be707adf5fe5d8dd",
        "reportUrl" : "https://YaroslavS1.github.io/VKR_project/86//#testresult/be707adf5fe5d8dd",
        "status" : "skipped",
        "statusDetails" : "XFAIL this test is expecting failure\n\nFileNotFoundError: [Errno 2] No such file or directory: '../case/cashe.csv'",
        "time" : {
          "start" : 1649530694123,
          "stop" : 1649530694125,
          "duration" : 2
        }
      } ]
    },
    "tags" : [ "@pytest.mark.xfail(condition=<function <lambda> at 0x7f1698de8310>, reason='this test is expecting failure')" ]
  },
  "source" : "aad32a1c16c5f9b2.json",
  "parameterValues" : [ ]
}